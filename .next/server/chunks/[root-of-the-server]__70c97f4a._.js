module.exports = {

"[project]/.next-internal/server/app/api/sync/route/actions.js [app-rsc] (server actions loader, ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
}}),
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/path [external] (path, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("path", () => require("path"));

module.exports = mod;
}}),
"[externals]/fs [external] (fs, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}}),
"[externals]/util [external] (util, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}}),
"[externals]/stream [external] (stream, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}}),
"[externals]/http [external] (http, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}}),
"[externals]/https [external] (https, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}}),
"[externals]/url [external] (url, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}}),
"[externals]/crypto [external] (crypto, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}}),
"[externals]/assert [external] (assert, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("assert", () => require("assert"));

module.exports = mod;
}}),
"[externals]/tty [external] (tty, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("tty", () => require("tty"));

module.exports = mod;
}}),
"[externals]/os [external] (os, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("os", () => require("os"));

module.exports = mod;
}}),
"[externals]/zlib [external] (zlib, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}}),
"[externals]/events [external] (events, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}}),
"[project]/services/flowtrac.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "fetchFlowtracInventory": ()=>fetchFlowtracInventory,
    "filterProductsToSync": ()=>filterProductsToSync,
    "testFlowtracConnection": ()=>testFlowtracConnection
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$axios$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/axios/lib/axios.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$qs$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/qs/lib/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/fs [external] (fs, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/path [external] (path, cjs)");
;
;
;
;
const FLOWTRAC_API_URL = process.env.FLOWTRAC_API_URL;
const FLOWTRAC_BADGE = process.env.FLOWTRAC_BADGE;
const FLOWTRAC_PIN = process.env.FLOWTRAC_PIN;
const mappingPath = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].join(process.cwd(), 'mapping.json');
async function getFlowtracAuthCookie() {
    const loginRes = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$axios$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].post(`${FLOWTRAC_API_URL}/device-login/`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$qs$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].stringify({
        badge: FLOWTRAC_BADGE,
        pin: FLOWTRAC_PIN
    }), {
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded'
        },
        withCredentials: true
    });
    const cookies = loginRes.headers['set-cookie'];
    if (!cookies) throw new Error('No session cookie from Flowtrac login');
    const flowAuthCookie = cookies.find((c)=>c.startsWith('flow_auth='));
    if (!flowAuthCookie) throw new Error('No flow_auth cookie from Flowtrac login');
    return flowAuthCookie;
}
async function fetchAllFlowtracProducts(flowAuthCookie) {
    const productsRes = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$axios$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].get(`${FLOWTRAC_API_URL}/products`, {
        headers: {
            Cookie: flowAuthCookie
        },
        withCredentials: true
    });
    return productsRes.data;
}
function getProductIdForSku(sku, mapping) {
    for (const product of mapping.products){
        if (product.flowtrac_sku === sku && product.flowtrac_product_id) return product.flowtrac_product_id;
        if (product.bundle_components) {
            for (const comp of product.bundle_components){
                if (comp.flowtrac_sku === sku && comp.flowtrac_product_id) return comp.flowtrac_product_id;
            }
        }
    }
    return undefined;
}
function setProductIdForSku(sku, product_id, mapping) {
    let updated = false;
    for (const product of mapping.products){
        if (product.flowtrac_sku === sku) {
            if (product.flowtrac_product_id !== product_id) {
                product.flowtrac_product_id = product_id;
                updated = true;
            }
        }
        if (product.bundle_components) {
            for (const comp of product.bundle_components){
                if (comp.flowtrac_sku === sku) {
                    if (comp.flowtrac_product_id !== product_id) {
                        comp.flowtrac_product_id = product_id;
                        updated = true;
                    }
                }
            }
        }
    }
    return updated;
}
async function fetchFlowtracInventory(skus) {
    // 1. Authenticate to get session cookie
    const flowAuthCookie = await getFlowtracAuthCookie();
    // 2. Load mapping.json
    const mapping = JSON.parse(__TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].readFileSync(mappingPath, 'utf-8'));
    // 3. Fetch all Flowtrac products once (for self-healing)
    const products = await fetchAllFlowtracProducts(flowAuthCookie);
    const skuToProductId = {};
    for (const p of products){
        if (p.product) skuToProductId[p.product] = p.product_id;
        if (p.barcode) skuToProductId[p.barcode] = p.product_id;
    }
    let mappingUpdated = false;
    // 4. Ensure all SKUs have product_id, self-heal if missing
    const skuToPidForQuery = {};
    for (const sku of skus){
        let pid = getProductIdForSku(sku, mapping);
        if (!pid) {
            pid = skuToProductId[sku];
            if (pid) {
                if (setProductIdForSku(sku, pid, mapping)) mappingUpdated = true;
            } else {
                throw new Error(`SKU '${sku}' not found in Flowtrac products.`);
            }
        }
        skuToPidForQuery[sku] = pid;
    }
    if (mappingUpdated) {
        __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].writeFileSync(mappingPath, JSON.stringify(mapping, null, 2));
        console.log('mapping.json updated with missing Flowtrac product_ids during sync.');
    }
    // 5. Query Flowtrac using product_id for each SKU
    const inventory = {};
    const today = new Date();
    for (const [sku, product_id] of Object.entries(skuToPidForQuery)){
        // Query all bins for the product_id
        const params = {
            product_id
        };
        const binsRes = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$axios$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].get(`${FLOWTRAC_API_URL}/product-warehouse-bins`, {
            headers: {
                Cookie: flowAuthCookie
            },
            params,
            withCredentials: true
        });
        const bins = binsRes.data;
        // Sum 'quantity' where include_in_available is 'Yes', warehouse is 'Manteca', and not expired
        inventory[sku] = bins.filter((b)=>{
            if (b.include_in_available !== 'Yes') return false;
            if (b.warehouse !== 'Manteca') return false;
            if (b.expiration_date) {
                const exp = new Date(b.expiration_date);
                if (exp < today) return false;
            }
            return true;
        }).reduce((sum, b)=>sum + (Number(b.quantity) || 0), 0);
    }
    return inventory;
}
function filterProductsToSync(flowtracProducts, onlyActive = true) {
    // Load mapping.json (assume project root)
    const mappingPath = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].resolve(("TURBOPACK compile-time value", "/ROOT/services"), '../../../mapping.json');
    const mapping = JSON.parse(__TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].readFileSync(mappingPath, 'utf-8'));
    // Collect all mapped SKUs from simple and bundle products
    const mappedSkus = new Set();
    for (const product of mapping.products){
        if ('flowtrac_sku' in product && product.flowtrac_sku) {
            mappedSkus.add(product.flowtrac_sku);
        }
        if ('bundle_components' in product && Array.isArray(product.bundle_components)) {
            for (const comp of product.bundle_components){
                if (comp.flowtrac_sku) mappedSkus.add(comp.flowtrac_sku);
            }
        }
    }
    // Filter Flowtrac products by SKU and (optionally) active status
    return flowtracProducts.filter((p)=>mappedSkus.has(p.product) && (!onlyActive || p.active === 'Active'));
}
async function testFlowtracConnection() {
    try {
        // 1. Login to get session cookie
        const loginRes = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$axios$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].post(`${FLOWTRAC_API_URL}/device-login/`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$qs$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].stringify({
            badge: FLOWTRAC_BADGE,
            pin: FLOWTRAC_PIN
        }), {
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded'
            },
            withCredentials: true
        });
        // Log the full response for troubleshooting
        console.log('Flowtrac loginRes.headers:', loginRes.headers);
        console.log('Flowtrac loginRes.data:', loginRes.data);
        const cookies = loginRes.headers['set-cookie'];
        if (!cookies || !cookies.length) {
            return {
                error: 'No session cookie returned from device-login.',
                headers: loginRes.headers,
                data: loginRes.data
            };
        }
        const flowAuthCookie = cookies.find((c)=>c.startsWith('flow_auth='));
        if (!flowAuthCookie) {
            return {
                error: 'No flow_auth session cookie found.',
                headers: loginRes.headers,
                data: loginRes.data
            };
        }
        // 2. Use flow_auth cookie to fetch products (no limit param)
        try {
            const productsRes = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$axios$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].get(`${FLOWTRAC_API_URL}/products`, {
                headers: {
                    'Content-Type': 'application/json',
                    'Cookie': flowAuthCookie.split(';')[0]
                }
            });
            return productsRes.data;
        } catch (productsError) {
            // Log the full error response
            console.log('Flowtrac productsError.response?.data:', productsError.response?.data);
            console.log('Flowtrac productsError.response?.headers:', productsError.response?.headers);
            return {
                error: productsError.message,
                data: productsError.response?.data,
                headers: productsError.response?.headers
            };
        }
    } catch (error) {
        return {
            error: error.message
        };
    }
}
}),
"[project]/services/shopify.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "enrichMappingWithShopifyVariantAndInventoryIds": ()=>enrichMappingWithShopifyVariantAndInventoryIds,
    "getMantecaLocationId": ()=>getMantecaLocationId,
    "updateShopifyInventory": ()=>updateShopifyInventory
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$axios$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/axios/lib/axios.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/fs [external] (fs, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/path [external] (path, cjs)");
;
;
;
const SHOPIFY_API_KEY = process.env.SHOPIFY_API_KEY;
const SHOPIFY_API_PASSWORD = process.env.SHOPIFY_API_PASSWORD;
const SHOPIFY_STORE_URL = process.env.SHOPIFY_STORE_URL;
const SHOPIFY_API_VERSION = process.env.SHOPIFY_API_VERSION || '2023-10';
const mappingPath = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].join(process.cwd(), 'mapping.json');
const shopifyGraphqlUrl = `https://${SHOPIFY_STORE_URL}/admin/api/${SHOPIFY_API_VERSION}/graphql.json`;
async function getVariantAndInventoryItemIdBySku(sku) {
    const query = `
    query GetVariantAndInventoryBySku($sku: String!) {
      products(first: 1, query: $sku) {
        edges {
          node {
            variants(first: 10) {
              edges {
                node {
                  id
                  sku
                  inventoryItem {
                    id
                  }
                }
              }
            }
          }
        }
      }
    }
  `;
    const variables = {
        sku
    };
    const response = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$axios$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].post(shopifyGraphqlUrl, {
        query,
        variables
    }, {
        headers: {
            'Content-Type': 'application/json',
            'X-Shopify-Access-Token': SHOPIFY_API_PASSWORD
        }
    });
    const products = response.data.data.products.edges;
    for (const productEdge of products){
        for (const variantEdge of productEdge.node.variants.edges){
            if (variantEdge.node.sku === sku) {
                return {
                    variantId: variantEdge.node.id,
                    inventoryItemId: variantEdge.node.inventoryItem.id
                };
            }
        }
    }
    return {
        variantId: null,
        inventoryItemId: null
    };
}
let mantecaLocationId = null;
async function getMantecaLocationId() {
    if (mantecaLocationId) return mantecaLocationId;
    const url = `https://${SHOPIFY_STORE_URL}/admin/api/${SHOPIFY_API_VERSION}/locations.json`;
    const response = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$axios$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].get(url, {
        headers: {
            'Content-Type': 'application/json',
            'X-Shopify-Access-Token': SHOPIFY_API_PASSWORD
        }
    });
    const locations = response.data.locations;
    const manteca = locations.find((loc)=>loc.name.toLowerCase() === 'manteca');
    if (!manteca) throw new Error('Manteca location not found in Shopify locations');
    mantecaLocationId = manteca.id.toString();
    return mantecaLocationId;
}
function extractIdFromGid(gid) {
    // e.g., gid://shopify/InventoryItem/53137749803317 -> 53137749803317
    return gid.split('/').pop() || gid;
}
async function updateShopifyInventory(inventoryItemId, available) {
    if (!inventoryItemId) throw new Error('inventoryItemId is required for updateShopifyInventory');
    const locationId = await getMantecaLocationId();
    const url = `https://${SHOPIFY_STORE_URL}/admin/api/${SHOPIFY_API_VERSION}/inventory_levels/set.json`;
    const payload = {
        location_id: locationId,
        inventory_item_id: extractIdFromGid(inventoryItemId),
        available
    };
    const headers = {
        'Content-Type': 'application/json',
        'X-Shopify-Access-Token': SHOPIFY_API_PASSWORD
    };
    console.log('[Shopify Debug] Inventory Update URL:', url);
    console.log('[Shopify Debug] Payload:', JSON.stringify(payload));
    console.log('[Shopify Debug] Headers:', headers);
    try {
        await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$axios$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].post(url, payload, {
            headers
        });
    } catch (error) {
        console.error('[Shopify Debug] Error updating inventory:', error.response?.data || error.message);
        throw error;
    }
}
async function enrichMappingWithShopifyVariantAndInventoryIds() {
    const mapping = JSON.parse(__TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].readFileSync(mappingPath, 'utf-8'));
    let updated = false;
    for (const product of mapping.products){
        if (product.shopify_sku && (!product.shopify_variant_id || !product.shopify_inventory_item_id)) {
            const { variantId, inventoryItemId } = await getVariantAndInventoryItemIdBySku(product.shopify_sku);
            if (variantId) {
                product.shopify_variant_id = variantId;
                updated = true;
            }
            if (inventoryItemId) {
                product.shopify_inventory_item_id = inventoryItemId;
                updated = true;
            }
        }
        if (Array.isArray(product.bundle_components)) {
            continue;
        }
    }
    if (updated) {
        __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].writeFileSync(mappingPath, JSON.stringify(mapping, null, 2));
        console.log('mapping.json updated with Shopify variant and inventory item IDs.');
    }
}
}),
"[project]/src/app/api/sync/route.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "GET": ()=>GET,
    "POST": ()=>POST
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
// import { rateLimit } from '../../middleware/rateLimit';
var __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/path [external] (path, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/fs [external] (fs, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$services$2f$flowtrac$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/services/flowtrac.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$services$2f$shopify$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/services/shopify.ts [app-route] (ecmascript)");
;
;
;
;
;
async function POST(request) {
    // Rate limiting
    // const rateLimitResult = rateLimit(request);
    // if (rateLimitResult) return rateLimitResult;
    console.log('Sync job started');
    try {
        // 1. Load mapping.json
        const mappingPath = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].join(process.cwd(), 'mapping.json');
        console.log('DEBUG: Resolved mappingPath in API route:', mappingPath);
        let mapping = JSON.parse(__TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].readFileSync(mappingPath, 'utf-8'));
        // 2. Collect all SKUs (simple and bundle components)
        const skus = new Set();
        for (const product of mapping.products){
            if (product.flowtrac_sku) skus.add(product.flowtrac_sku);
            if (Array.isArray(product.bundle_components)) {
                for (const comp of product.bundle_components){
                    if (comp.flowtrac_sku) skus.add(comp.flowtrac_sku);
                }
            }
        }
        // 3. Fetch inventory data from Flowtrac
        const flowtracInventory = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$services$2f$flowtrac$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["fetchFlowtracInventory"])(Array.from(skus));
        console.log('Fetched Flowtrac inventory', {
            flowtracInventory
        });
        // 4. Build shopifyInventory map (simple and bundle SKUs)
        const shopifyInventory = {};
        for (const product of mapping.products){
            if (Array.isArray(product.bundle_components) && product.shopify_sku) {
                const quantities = product.bundle_components.map((comp)=>{
                    const available = flowtracInventory[comp.flowtrac_sku] || 0;
                    return Math.floor(available / comp.quantity);
                });
                shopifyInventory[product.shopify_sku] = quantities.length > 0 ? Math.min(...quantities) : 0;
            } else if (product.shopify_sku && product.flowtrac_sku) {
                shopifyInventory[product.shopify_sku] = flowtracInventory[product.flowtrac_sku] || 0;
            }
        }
        // 5. Self-heal: Enrich mapping.json with missing Shopify variant and inventory item IDs
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$services$2f$shopify$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["enrichMappingWithShopifyVariantAndInventoryIds"])();
        // Reload mapping after enrichment
        const updatedMapping = JSON.parse(__TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].readFileSync(mappingPath, 'utf-8'));
        // 6. Update inventory in Shopify for each SKU
        const updateResults = {};
        for (const [sku, quantity] of Object.entries(shopifyInventory)){
            const product = updatedMapping.products.find((p)=>p.shopify_sku === sku);
            const inventoryItemId = product?.shopify_inventory_item_id;
            if (!inventoryItemId) {
                updateResults[sku] = {
                    success: false,
                    error: 'No shopify_inventory_item_id in mapping.json'
                };
                console.error(`No shopify_inventory_item_id for SKU ${sku}`);
                continue;
            }
            try {
                await (0, __TURBOPACK__imported__module__$5b$project$5d2f$services$2f$shopify$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["updateShopifyInventory"])(inventoryItemId, quantity);
                updateResults[sku] = {
                    success: true
                };
                console.log(`Updated Shopify inventory for SKU ${sku} (inventory item ${inventoryItemId}) to ${quantity}`);
            } catch (err) {
                updateResults[sku] = {
                    success: false,
                    error: err.message
                };
                console.error(`Failed to update Shopify inventory for SKU ${sku}: ${err.message}`);
            }
        }
        console.log('Sync job completed successfully');
        // 7. Return success response
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: true,
            message: 'Sync completed.',
            shopifyInventory,
            updateResults
        });
    } catch (error) {
        console.error('Sync job failed', {
            error
        });
        // Handle errors
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: false,
            error: error.message
        }, {
            status: 500
        });
    }
}
async function GET(request) {
    // Optionally allow GET for testing
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
        message: 'Sync endpoint is up.'
    });
}
}),

};

//# sourceMappingURL=%5Broot-of-the-server%5D__70c97f4a._.js.map